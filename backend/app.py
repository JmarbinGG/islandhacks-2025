import os
import time
import pandas as pd
from openai import OpenAI
from flask import Flask, request, jsonify
from flask_cors import CORS
from dotenv import load_dotenv
from julius_api import Julius
import sqlite3
import boto3
import io
from math import gcd
from datetime import datetime
from xai_sdk import Client
from xai_sdk.chat import user, system
from perplexity import Perplexity


load_dotenv()

aws_s3_bucket_name = "lightathon"
aws_region = "us-west-1"
aws_access_key = os.getenv("AWS_ACCESS_KEY")
aws_secret_key = os.getenv("AWS_SECRET_KEY")

openai_prompt="You are an academic data analyst. The user will upload a CSV and a summary from Julius AI. Analyze both carefully, identify patterns, gaps, or trends in the CSV, and then generate **new ideas or suggestions** to enhance the previous advice. Keep the original advice intact, but add actionable insights based on your analysis. Output only the updated advice with the added ideas, no extra text."
grok_prompt="You are a performance critic and data analyst. The user will upload a CSV and a ChatGPT analysis. Critically evaluate the previous advice: identify strengths, weaknesses, and any gaps or redundancies. Then analyze the CSV to confirm trends or highlight additional insights. Finally, generate a **concise, clear, and actionable summary** that synthesizes all previous advice and CSV analysis. Output only this synthesized summary, no extra text."
perplexity_prompt="You are a data auditor and analyst. The user will upload a CSV and the concise summary generated by Grok. Analyze the CSV deeply to identify any anomalies, inconsistencies, or data points that conflict with the summary. Highlight discrepancies between the summary and the actual CSV data, and provide clarifications or corrections where needed. Output only the summary with your clarifications and corrections, no extra text."
deepseek_prompt="You are a summary optimizer. The user will upload a CSV, a summary from Julius AI, ChatGPT, GROK and Perplexity. Analyze the CSV and all previous insights, then generate a **final, comprehensive summary** that integrates all insights into a coherent narrative. Ensure the summary is clear, concise, and actionable, providing a holistic view of the data and previous analyses. Output only this final summary, no extra text."



app = Flask(__name__)
CORS(app)  
openai_client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))
julius_client = Julius(api_key=os.getenv("JULIUS_API_TOKEN"))
grok_client = Client(api_key=os.getenv("GROK_API_KEY"), timeout=3600)
#gpt 5 for openai
perplexity_client = Perplexity(api_key=os.getenv("PERPLEXITY_API_KEY"))
deepseek_client = OpenAI(api_key=os.environ.get('DEEPSEEK_API_KEY'), base_url="https://api.deepseek.com")

grok_chat = grok_client.chat.create(model="grok-4")

'''
julius
chatgpt(ideas)
xai(critique)
perplexity(fact check)
deepseek(summarize)
'''

@app.route("/api/council-of-clankers")
def council_of_clankers():
    og_julius_response = "Julius output:" + read(request.args.get("share_code"))[0]['ai_analy']
    csv_string = download_s3_file_to_string(aws_s3_bucket_name, read(request.args.get("share_code"))[0]['s3_link'])
    
    print("CSV STRING:", csv_string)
    print("JULIUS RESPONSE:", og_julius_response)

    gptresponse = openai_client.chat.completions.create(
        model="gpt-4o",
        messages=[
            {
                "role": "system",
                "content": openai_prompt
            },
            {
                "role": "user",
                "content": csv_string + "\n\n" + og_julius_response
            }
        ],
    )
    gpt_output = "Chatgpt Output: " + gptresponse.choices[0].message.content
    print("GPT OUTPUT:", gpt_output)
    
    
    grok_chat.append(system(grok_prompt))
    grok_chat.append(user(csv_string + "\n\n" + og_julius_response + "\n\n" + gpt_output))
    grok_output = "Grok Output: " + grok_chat.sample().content
    print(grok_output)


    perplexity_response = perplexity_client.chat.completions.create(
        model="sonar",
        messages=[
            {
                "role": "system",
                "content": perplexity_prompt
            },
            {
                "role": "user",
                "content": csv_string + "\n\n" + og_julius_response + "\n\n" + gpt_output + "\n\n" + grok_output
            }
        ]
    )
    perplexity_output = "Perplexity Output: " + perplexity_response.choices[0].message.content
    print("PERPLEXITY OUTPUT:", perplexity_output)
    
    deepseek_response = deepseek_client.chat.completions.create(
        model="deepseek-reasoner",
        messages=[
            {
                "role": "system",
                "content": deepseek_prompt
            },
            {
                "role": "user",
                "content": csv_string + "\n\n" + og_julius_response + "\n\n" + gpt_output + "\n\n" + grok_output + "\n\n" + perplexity_output
            }
        ]
    )
    print("DEEPSEEK OUTPUT:", deepseek_response.choices[0].message.content)

    return jsonify({"output": deepseek_output})




'''
chat = client.chat.create(model="grok-4")
chat.append(system("You are Grok, a highly intelligent, helpful AI assistant."))
chat.append(user("What is the meaning of life, the universe, and everything?"))

response = chat.sample()
print(response.content)
'''


@app.route("/")
def home():
    return "Welcome to the Student Life AI Backend!"

@app.route("/api/ping")
def ping():
    return jsonify({"message": "Pong from Flask backend!"})

@app.route("/api/test")
def test():
    return jsonify({"message": "Flask backend working!"})

@app.route("/api/analyze")
def tocsv():
    try:
        # Get data from POST body
        data = request.args.get("data")
        if not data:
            return jsonify({"error": "Missing 'data' field in request body"}), 400
        
        grade_data = data
        
        if not grade_data or not isinstance(grade_data, str):
            return jsonify({"error": "'data' must be a non-empty string"}), 400
        
        # Convert grade data to CSV using GPT
        gptresponse = openai_client.chat.completions.create(
            model="gpt-4o",
            messages=[
                {
                    "role": "system",
                    "content": "You are a data converter for a grading app. the user will paste all the text from their grading app, and it is your job to filter it to only the assignments and their grades, ignore all other text. Then, convert the assignment data into a csv. Ensure the data is clean and well-structured. ONLY return the data in csv format, no extra text. If any data is missing, leave the field blank but keep the structure intact."
                },
                {
                    "role": "user",
                    "content": grade_data
                }
            ]
        )
    
        
        csv_content = gptresponse.choices[0].message.content
        filename = datetime.now().strftime("%Y-%m-%d %H:%M:%S")+".csv"
        sharecode = generate_code()
        
        # Save CSV file
        with open(filename, "w") as f:
            f.write(csv_content)
        
        # Try Julius API, fallback to GPT if it fails
        ai_analysis = ""
        try:
            julresponse = julius_client.chat.completions.create(
                model="default",
                messages=[
                    {
                        "role": "user",
                        "content": "Take CSV data containing grades and performance categories. Analyze the data and identify the specific reasons a grade might be dropping (for example: poor grammar lowering an English grade, missing assignments lowering a math grade, etc.). Then give clear, practical steps to improve those areas. Output only the conclusions and improvement advice - no extra text. output it as plain text, no formatting. When doing a new line, use two backslashes followed by an n. The csv data is: " + csv_content,
                        "advanced_reasonsing": False
                    }
                ],
            )
            ai_analysis = julresponse.message.content
            print("Julius analysis completed")
        except Exception as julius_error:
            print(f"Julius API failed: {julius_error}. Falling back to GPT-4o")
            # Fallback to GPT-4o for analysis
            fallback_response = openai_client.chat.completions.create(
                model="gpt-4o",
                messages=[
                    {
                        "role": "system",
                        "content": "You are an academic advisor analyzing student grade data. Identify specific reasons grades might be dropping and provide clear, practical improvement steps. output it as plain text, no formatting. When doing a new line, use two backslashes followed by an n."
                    },
                    {
                        "role": "user",
                        "content": f"Analyze this CSV data and identify reasons for poor performance with actionable advice:\n\n{csv_content}"
                    }
                ]
            )
            ai_analysis = fallback_response.choices[0].message.content
        
        # Upload to S3 and save to database
        s3_upload(filename)
        write((sharecode, filename, ai_analysis))
        
        return sharecode
    
    except Exception as e:
        print(f"Error in /api/analyze: {str(e)}")
        return jsonify({"error": str(e)}), 500


@app.route("/api/retrieve")
def retrieve():
    code = request.args.get("code")
    result = read(code)
    if result:
        return jsonify({
            "s3_link": result[0]['s3_link'],
            "ai_analysis": result[0]['ai_analy']
        })
    else:
        return jsonify({"error": "Code not found"}), 404


def s3_upload(filename):
    s3_client = boto3.client(
        service_name='s3',
        region_name=aws_region,
        aws_access_key_id=aws_access_key,
        aws_secret_access_key=aws_secret_key
    )
    response = s3_client.upload_file(filename, aws_s3_bucket_name, filename)
    print(response)


def read(code):
    connection = get_connection()
    cursor = connection.cursor()
    thingy = cursor.execute("SELECT * FROM tip WHERE share_code = ?", (code,))
    r = [dict((cursor.description[i][0], value) for i, value in enumerate(row)) for row in cursor.fetchall()]
    connection.close()
    return r

def generate_code():
    connection = get_connection()
    cursor = connection.cursor()
    cursor.execute("SELECT MAX(id) FROM tip")
    max_id = cursor.fetchone()[0]
    if max_id is None:
        max_id = 0
    new_id = max_id + 1
    connection.close()
    code = int_to_code(new_id)
    return code

def decode_code(code):
    id = code_to_int(code)
    return id


def write(values):
    connection = get_connection()
    cursor = connection.cursor()
    thingy = cursor.execute("INSERT INTO tip (share_code,s3_link,ai_analy) VALUES (?,?,?)", values)
    connection.commit()
    connection.close()


def get_connection():
    conn = sqlite3.connect('shaft.db')
    return conn





#share code logic
ALPHABET = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
BASE = len(ALPHABET)
LENGTH = 6
MOD = BASE ** LENGTH          

a = 35450549
b = 2750043
assert gcd(a, MOD) == 1

def base62_encode(n: int) -> str:
    s = []
    for _ in range(LENGTH):
        n, r = divmod(n, BASE)
        s.append(ALPHABET[r])
    return "".join(reversed(s))

def base62_decode(s: str) -> int:
    n = 0
    for ch in s:
        n = n * BASE + ALPHABET.index(ch)
    return n

def int_to_code(x: int) -> str:
    y = (a * x + b) % MOD
    return base62_encode(y)

def code_to_int(code: str) -> int:
    y = base62_decode(code)
    a_inv = pow(a, -1, MOD)
    return (a_inv * (y - b)) % MOD

def download_s3_file_to_string(bucket_name, object_key):
    try:
        s3 = boto3.client(
            service_name='s3',
            region_name=aws_region,
            aws_access_key_id=aws_access_key,
            aws_secret_access_key=aws_secret_key
        )
        
        # Create a BytesIO object to store the file content in memory
        buffer = io.BytesIO()
        
        # Download the S3 object into the buffer
        s3.download_fileobj(Bucket=bucket_name, Key=object_key, Fileobj=buffer)
        
        # Get the content from the buffer as bytes
        file_content_bytes = buffer.getvalue()
        
        # Decode the bytes to a string (assuming UTF-8 encoding)
        file_content_str = file_content_bytes.decode('utf-8')
        
        return file_content_str
        
    except Exception as e:
        print(f"Error downloading or decoding file: {e}")
        return None

if __name__ == "__main__":
    app.run(port=8000, debug=True)